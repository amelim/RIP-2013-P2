addpath('./');addpath('./kinematics');addpath('./visualization');% Start and goal location according to assignment 2ps = [2.6, 1.3, 1.0];pg = [-1.4, 1.6, -2.0];% Test goal positions% pg = [-3, 1.5, -2.0];% pg = [-2.6, -1.3, -1.0];% pg = [-2.6, 0, -1.0];l1 = 2;l2 = 2;l3 = 1;ql = [l1, l2, l3];q = [1.2283; -2.0151; 1.8169]; % exact iteratively found joint angles                                % for the start position% -------------------------------------------------------------------------% GENERAL APPROACH% Recompute Jacobian and inverse Jacobian for every timestep since Jacobian% is only valid in a small region around linearization point% -------------------------------------------------------------------------% ----------------------% Closed loop controller% ----------------------steps = 200;epsilon = 0.025;% Compute initial Jacobian matrixJ = armJacobian(q, ql);% Compute initial position of robotx = fk(q, ql)';% Compute initial linear velocities of eedx      = pg(1) - x(1);dy      = pg(2) - x(2);dtheta  = pg(3) - x(3);vx = dx / steps;vy = dy / steps;w  = dtheta / steps;xDot    = [vx; vy; w];% Initialize data vectorsqSum    = q;X       = x;for i = 1:1:steps    %x = x + xDot;    x = fk(q, ql)';    X = [X, x];        % Compute joint velocities based on linear end effector velocities    if(rank(J) < 3)        disp('J is singular');    end        % Compute joint velocities based on inverse Jacobian    qDot = inv(J) * xDot;        % Recompute joint angles with inverse Jacobian keeping in mind that    % xDot = J * qDot --> qDot = inv(J) * xDot    q = q + qDot;    qSum = [qSum q];        % Recompute Jacobian    J = armJacobian(q, ql);        % Recompute current error    dx      = pg(1) - x(1);    dy      = pg(2) - x(2);    dtheta  = pg(3) - x(3);    %     disp(['Current error dx/dy/dtheta: ', num2str(dx), ...%         ' / ', num2str(dy), ' / ', num2str(dtheta)]);        % Recompute velocities    vx = dx / steps;    vy = dy / steps;    w  = dtheta / steps;    xDot    = [vx; vy; w];    xDot = 0.05 * xDot / norm(xDot);        % Abort if we are close enough to goal    if(norm(pg' - x) < epsilon)        disp(['Goal successfully reached: ', num2str(pg)]);        break    endend% Visualize trajectorydrawArm3(qSum', ql, 0.05, 'test', '', ps, pg);%% Open loop controllersteps = 100;dx      = pg(1) - ps(1);dy      = pg(2) - ps(2);dtheta  = pg(3) - ps(3);vx = dx / steps;vy = dy / steps;w  = dtheta / steps;x       = ps(1:3)';xDot    = [vx; vy; w];qSum    = q;X       = x;for i = 1:1:steps    x = x + xDot;    X = [X, x];        % Compute joint velocities based on linear end effector velocities    if(rank(J) < 3)        disp('J is singular');    end        qDot = inv(J) * xDot;        % Recompute joint angles with inverse Jacobian keeping in mind that    % xDot = J * qDot --> qDot = inv(J) * xDot    q = q + qDot;    qSum = [qSum q];        % Recompute Jacobian    J = armJacobian(q, ql);enddrawArm3(qSum', ql, 0.05, ps, pg);%% Visualize desired path of ee vs. actual pathfor i = 1:1:length(qSum)    ee = fk(qSum(1:3, i), ql);        plot(ee(1), ee(2), 'rx'); hold on;    plot(X(1, i), X(2, i), 'bx');    axis([min(ps(1), pg(1)) - 1, max(ps(1), pg(1)) + 1, min(ps(2), pg(2)) - 1, max(ps(2), pg(2)) + 1])    %pause(0.05)end